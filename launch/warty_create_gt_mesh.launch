<?xml version="1.0" encoding="ISO-8859-15"?>
<launch>
  <arg name="voxel_size"     default="0.05"/>
  <arg name="max_ray_length_m" default="40"/>
  <arg name="use_sim_time"     default="true"/>
  <param name="use_sim_time"   value="$(arg use_sim_time)" />
  <arg name="semantic_labels_path" default="$(find kimera_distributed)/params/dcist_camp_semantic_mapping.csv" />
  <arg name="bag_file" default="$(find kimera_semantics_ros)/rosbags/kimera_semantics_demo.bag"/>
  <arg name="play_bag" default="true"/>
  <arg name="sensor_frame" default="warty/camera_optical_frame" />

  <arg name="rosbag_rate" default="0.1"/>
  <node name="player" pkg="rosbag" type="play"
    args="--clock --rate $(arg rosbag_rate) $(arg bag_file)"  if="$(arg play_bag)">
    <remap from="/warty/tf" to="/tf" />
    <remap from="/warty/tf_static" to="/tf_static" />
  </node>

  <node pkg="tf" type="static_transform_publisher" name="gt_to_robot" args="0 0 0 0 0 0 1 ground_truth/warty/base warty/base 100"/>
  <node pkg="tf" type="static_transform_publisher" name="robot_to_cam" args="0 0 0 0 0 0 1 warty/camera warty/camera_optical_frame 100"/>
  <node pkg="tf" type="static_transform_publisher" name="cam_to_depth" args="0 0 0 0 0 0 1 warty/camera warty/depth_camera_optical_frame 100"/>

  <!-- Run 3D reconstruction without semantics, set this flag to false-->
  <arg name="metric_semantic_reconstruction" default="true"/>

  <!-- Input -->
  <arg name="semantic_pointcloud"         default="/semantic_pointcloud"/>
  <arg name="left_cam_info_topic"         default="/warty/camera/camera_info"/>
  <arg name="right_cam_info_topic"        default="/warty/right_camera/camera_info"/>
  <arg name="seg_cam_info_topic"          default="/warty/camera/camera_info"/>
  <arg name="depth_cam_info_topic"        default="/warty/depth_camera/camera_info"/>
  <arg name="left_cam_topic"              default="/warty/camera/image"/>
  <arg name="right_cam_topic"             default="/warty/right_camera/image"/>
  <arg name="left_cam_segmentation_topic" default="/warty/camera/semantic_image"/>
  <arg name="left_cam_depth_topic"        default="/warty/depth_camera/image"/>
  <arg name="use_freespace_pointcloud"    default="false" />
  <arg name="freespace_pointcloud"        default="/dev/null"/>

  <!-- Launch Nodelet manager: used by depth_image_proc and disparity_image_proc -->
  <node pkg="nodelet" type="nodelet" name="nodelet_manager" args="manager"
    output="screen"/>

  <node pkg="nodelet" type="nodelet" name="depth_to_rgb"
  args="load depth_image_proc/register nodelet_manager --no-bond" output="screen">
    <!-- Input -->
    <remap from="rgb/camera_info" to="$(arg seg_cam_info_topic)" if="$(arg metric_semantic_reconstruction)"/>
    <remap from="rgb/camera_info" to="$(arg left_cam_info_topic)" unless="$(arg metric_semantic_reconstruction)"/> 
    <remap from="depth/camera_info" to="$(arg depth_cam_info_topic)"/> 
    <remap from="depth/image_rect" to="$(arg left_cam_depth_topic)"/>

    <!-- Output:  -->
    <remap from="depth_registered/image_rect" to="$(arg left_cam_depth_topic)/registered_info"/>
    <remap from="depth_registered/image_rect" to="$(arg left_cam_depth_topic)/registered"/> 
  </node>

  <!-- Converts registered depth image and RGB image into an RGB pointcloud.
       Using depth and semantic image, it generates semantic pointcloud. We only
      run this if we are not using stereo depth reconstruction instead. -->
       <!-- Get the scene depth image transformed to the rgb camera frame -->
  <node pkg="nodelet" type="nodelet" name="cloudify"
    args="load depth_image_proc/point_cloud_xyzrgb nodelet_manager
    -no-bond" output="screen">
    <!-- Input -->
    <remap from="rgb/camera_info"             to="$(arg left_cam_info_topic)"/>
    <remap from="rgb/image_rect_color"        to="$(arg left_cam_segmentation_topic)" if="$(arg metric_semantic_reconstruction)"/>
    <remap from="rgb/image_rect_color"        to="$(arg left_cam_topic)"              unless="$(arg metric_semantic_reconstruction)"/>
    <remap from="depth_registered/image_rect" to="$(arg left_cam_depth_topic)/registered"/>
    <!-- Output -->
    <remap from="depth_registered/points"     to="$(arg semantic_pointcloud)"/>
    <!-- Params -->
    <param name="rename_frame_id"             value="true" />
      <param name="frame_id"                  value="$(arg sensor_frame)" />
    <param name="queue_size"                  value="20"/>
  </node>

  <arg name="pkg_type"    default="kimera_semantics_ros"  if="$(arg metric_semantic_reconstruction)"/>
  <arg name="server_type" default="kimera_semantics_node" if="$(arg metric_semantic_reconstruction)"/>
  <arg name="pkg_type"    default="voxblox_ros" unless="$(arg metric_semantic_reconstruction)"/>
  <arg name="server_type" default="tsdf_server" unless="$(arg metric_semantic_reconstruction)"/>
  <node name="kimera_semantics_node" pkg="$(arg pkg_type)" type="$(arg server_type)" output="screen"
    args="-alsologtostderr -colorlogtostderr" clear_params="true">
    <!-- Input -->
    <remap from="pointcloud"                to="$(arg semantic_pointcloud)"/>

    <!-- Params -->
    <param name="tsdf_voxel_size"           value="$(arg voxel_size)" />
    <param name="tsdf_voxels_per_side"      value="16" />
    <param name="max_ray_length_m"          value="$(arg max_ray_length_m)" />
    <param name="min_time_between_msgs_sec" value="0.8" />
    <param name="pointcloud_queue_size"     value="10" />
    <param name="voxel_carving_enabled"     value="true" />
    <param name="color_mode"                value="color"/>
    <param name="use_const_weight"          value="false" />
    <param name="use_freespace_pointcloud"  value="$(arg use_freespace_pointcloud)" />
    <remap from="freespace_pointcloud"      to="$(arg freespace_pointcloud)"/>

    <param name="sensor_frame"              value="$(arg sensor_frame)"/>
    <param name="use_tf_transforms"         value="true" />

    <param name="enable_icp"                value="false" />
    <param name="icp_iterations"            value="10" />

    <param name="verbose"                   value="true" />

    <!-- Method to update voxels' information: "fast" or "merged" -->
    <param name="method"                           value="fast" />
    <!-- "color", "semantic" or "semantic_probability" -->
    <param name="semantic_color_mode"              value="semantic"/>
    <param name="semantic_measurement_probability" value="0.8" />
    <!-- The only dynamic label we have right now are humans, with label 20 -->
    <rosparam param="dynamic_semantic_labels">[]</rosparam>

    <!-- Is this needed? -->
    <param name="slice_level" value="1.0" />

    <param name="semantic_label_2_color_csv_filepath" value="$(arg semantic_labels_path)"/>

    <param name="publish_pointclouds"     value="false"/>
    <param name="update_mesh_every_n_sec" value="0.1" />
    <param name="mesh_filename"           value="$(find kimera_semantics_ros)/mesh_results/$(anon tesse).ply" />
  </node>
</launch>
